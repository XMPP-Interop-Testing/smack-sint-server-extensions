package org.igniterealtime.smack.inttest.rfc6121;

import org.igniterealtime.smack.inttest.AbstractSmackIntegrationTest;
import org.igniterealtime.smack.inttest.SmackIntegrationTestEnvironment;
import org.igniterealtime.smack.inttest.TestNotPossibleException;
import org.igniterealtime.smack.inttest.annotations.SmackIntegrationTest;
import org.igniterealtime.smack.inttest.annotations.SpecificationReference;
import org.igniterealtime.smack.inttest.util.ResultSyncPoint;
import org.jivesoftware.smack.SmackException;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.iqrequest.IQRequestHandler;
import org.jivesoftware.smack.packet.IQ;
import org.jivesoftware.smack.packet.StanzaError;
import org.jivesoftware.smack.roster.Roster;
import org.jivesoftware.smack.roster.RosterEntry;
import org.jivesoftware.smack.roster.packet.RosterPacket;
import org.jivesoftware.smack.util.StringUtils;
import org.jxmpp.jid.BareJid;
import org.jxmpp.jid.impl.JidCreate;
import org.jxmpp.jid.parts.Localpart;

import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests that verify that behavior defined in section 2.6 "Roster Versioning" of section 2 "Managing the Roster" of RFC6121.
 *
 * Specifically, the tests in this class all assert that the roster pushes sent by the server contain unique 'ver'
 * attribute values.
 *
 * @author Guus der Kinderen, guus.der.kinderen@gmail.com
 */
@SpecificationReference(document = "RFC6121")
public class RFC6121Section2dot6cRosterIntegrationTest extends AbstractSmackIntegrationTest
{
    public RFC6121Section2dot6cRosterIntegrationTest(SmackIntegrationTestEnvironment environment) throws SmackException.NotConnectedException, SmackException.NoResponseException, InterruptedException, TestNotPossibleException
    {
        super(environment);

        try {
            conOne.sendIqRequestAndWaitForResponse(new RosterPacket());
        } catch (XMPPException.XMPPErrorException e) {
            if (e.getStanzaError().getCondition() == StanzaError.Condition.service_unavailable) {
                throw new TestNotPossibleException("Server does not support the roster namespace."); // This error is defined in RFC6121 Section 2.2
            }
        }

        if (!Roster.getInstanceFor(conOne).isRosterVersioningSupported()) {
            throw new TestNotPossibleException("Server does not support roster versioning feature.");
        }
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by adding a roster item).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemAddition() throws Exception
    {
        // Setup test fixture.
        final BareJid targetOne = JidCreate.bareFrom( Localpart.from("test-targetone-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );
        final BareJid targetTwo = JidCreate.bareFrom( Localpart.from("test-targettwo-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        startingPoint.addRosterItem(new RosterPacket.Item(targetOne, null));

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        change.addRosterItem(new RosterPacket.Item(targetTwo, null));

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "a new item for '" + targetTwo + "' was added");
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by removing a roster item).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemRemoval() throws Exception
    {
        // Setup test fixture.
        final BareJid target = JidCreate.bareFrom( Localpart.from("test-targetone-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        startingPoint.addRosterItem(new RosterPacket.Item(target, null));

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        final RosterPacket.Item item = new RosterPacket.Item(target, null);
        item.setItemType(RosterPacket.ItemType.remove);
        change.addRosterItem(item);

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "the pre-existing item '" + target + "' was removed");
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by adding a name/handle to a roster item).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemModificationHandleAddition() throws Exception
    {
        // Setup test fixture.
        final BareJid target = JidCreate.bareFrom( Localpart.from("test-target-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        startingPoint.addRosterItem(new RosterPacket.Item(target, null));

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        change.addRosterItem(new RosterPacket.Item(target, "FooBar"));

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "the name/handle of item '" + target + "' - previously unset - was set to 'FooBar'");
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by changing the name/handle of a roster item).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemModificationHandleModification() throws Exception
    {
        // Setup test fixture.
        final BareJid target = JidCreate.bareFrom( Localpart.from("test-target-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        startingPoint.addRosterItem(new RosterPacket.Item(target, "Old Name"));

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        change.addRosterItem(new RosterPacket.Item(target, "Updated Name"));

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "the name/handle of item '" + target + "' was changed from 'Old name' to 'Updated Name'");
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by removing the name/handle of a roster item).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemModificationHandleRemoval() throws Exception
    {
        // Setup test fixture.
        final BareJid target = JidCreate.bareFrom( Localpart.from("test-target-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        startingPoint.addRosterItem(new RosterPacket.Item(target, "FooBar"));

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        change.addRosterItem(new RosterPacket.Item(target, null));

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "the name/handle of item '" + target + "' - previously 'FooBar' - was removed");
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by adding a group to a roster item).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemModificationGroupAddition() throws Exception
    {
        // Setup test fixture.
        final BareJid target = JidCreate.bareFrom( Localpart.from("test-target-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        startingPoint.addRosterItem(new RosterPacket.Item(target, null));

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        final RosterPacket.Item item = new RosterPacket.Item(target, null);
        item.addGroupName("Test Group");
        change.addRosterItem(item);

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "item '" + target + "' - previously not in any group - was added to a group called 'Test Group'");
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by adding another group to a roster item).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemModificationGroupAdditionAnother() throws Exception
    {
        // Setup test fixture.
        final BareJid target = JidCreate.bareFrom( Localpart.from("test-target-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        final RosterPacket.Item startItem = new RosterPacket.Item(target, null);
        startItem.addGroupName("Test Group");
        startingPoint.addRosterItem(startItem);

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        final RosterPacket.Item changeItem = new RosterPacket.Item(target, null);
        changeItem.addGroupName("Test Group");
        changeItem.addGroupName("Additional Group");
        change.addRosterItem(changeItem);

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "item '" + target + "' - already in group 'Test Group' - was added to an additional group called 'Additional Group'");
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by changing the group of a roster item).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemModificationGroupModification() throws Exception
    {
        // Setup test fixture.
        final BareJid target = JidCreate.bareFrom( Localpart.from("test-target-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        final RosterPacket.Item startItem = new RosterPacket.Item(target, null);
        startItem.addGroupName("Test Group");
        startingPoint.addRosterItem(startItem);

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        final RosterPacket.Item changeItem = new RosterPacket.Item(target, null);
        changeItem.addGroupName("Changed Group");
        change.addRosterItem(changeItem);

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "item '" + target + "' was removed from group 'Test Group' and was added to a group called 'Changed Group'");
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by removing the roster item from one of its groups).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemModificationGroupRemoval() throws Exception
    {
        // Setup test fixture.
        final BareJid target = JidCreate.bareFrom( Localpart.from("test-target-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        final RosterPacket.Item startItem = new RosterPacket.Item(target, null);
        startItem.addGroupName("Test Group");
        startItem.addGroupName("Additional Group");
        startingPoint.addRosterItem(startItem);

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        final RosterPacket.Item changeItem = new RosterPacket.Item(target, null);
        changeItem.addGroupName("Test Group");
        change.addRosterItem(changeItem);

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "item '" + target + "' was removed from group 'Additional Group', but remains in group 'Test Group'");
    }

    /**
     * Asserts that a unique 'ver' value is generated by the server when a roster is modified (by removing the roster item from its last group).
     */
    @SmackIntegrationTest(section = "2.6.3", quote = "the server MUST include the updated roster version with each roster push. [...] the version contained in a roster push MUST be unique.")
    public void testRosterItemModificationGroupRemovalLast() throws Exception
    {
        // Setup test fixture.
        final BareJid target = JidCreate.bareFrom( Localpart.from("test-target-" + StringUtils.randomString(5) ), conOne.getXMPPServiceDomain() );

        final RosterPacket startingPoint = new RosterPacket();
        startingPoint.setType(IQ.Type.set);
        startingPoint.addRosterItem(new RosterPacket.Item(target, "FooBar"));

        final RosterPacket change = new RosterPacket();
        change.setType(IQ.Type.set);
        change.addRosterItem(new RosterPacket.Item(target, null));

        // Delegate 'Execute System Under test' and 'Verify result'.
        doTestRosterChangeCausesVerDifference(startingPoint, change, "item '" + target + "' was removed from group 'Test Group' - which was the only group it was in");
    }

    /**
     * Asserts that the roster pushes sent by the server for the first and second roster change contain a different value
     * of the roster version ('ver' attribute value).
     *
     * During the fixture setup of this test:
     *
     * <ol>
     * <li>An initial roster change is applied</li>
     * <li>The roster push that should happen as a direct result of this, is waited for</li>
     * <li>The roster 'ver' of the state of the roster is recorded.</li>
     * </ul>
     *
     * During the execution of the system under test of this test:
     * <ol>
     * <li>An second roster change is applied</li>
     * <li>The roster push that should happen as a direct result of this, is waited for</li>
     * <li>The roster 'ver' of the state of the roster is recorded.</li>
     * </ol>
     *
     * During the result verification, it is checked that:
     * <ul>
     * <li>both 'ver' values are different from each-other</li>
     * </ul>
     *
     * The implementation of this test replaces Smack-based IQRequestHandlers that are registered by the Roster implementation.
     * This is done so that this test can detect roster pushes. The replacement IQRequestHandler delegates to the original request handler,
     * in an effort for Smack's functionality to remain functional. During the fixture teardown, the original IQRequestHandler is restored.
     * Any items that are added by the test are removed again from the roster.
     *
     * @param startingPoint A roster item that is used as the initial state.
     * @param change A roster item that is an update of the initial state.
     * @param descriptionOfChange A human-readable description of the roster item change (used for logging)
     */
    protected void doTestRosterChangeCausesVerDifference(final RosterPacket startingPoint, final RosterPacket change, final String descriptionOfChange) throws Exception
    {
        if (startingPoint == null || startingPoint.getRosterItems().size() != 1 || change == null || change.getRosterItems().size() != 1) {
            throw new IllegalArgumentException();
        }

        // Setup test fixture.
        final BareJid startingPointTarget = startingPoint.getRosterItems().iterator().next().getJid();
        final BareJid changeTarget = change.getRosterItems().iterator().next().getJid();

        // Setup test fixture: get the roster in a 'starting point' state.
        final String rosterVerWithoutModification = RosterPushListenerWithTarget.sendRosterChangeAndWaitForResultAndPush(conOne, timeout, startingPoint).getVersion();

        final RosterPushListenerWithTarget rosterPushHandler = new RosterPushListenerWithTarget();
        final IQRequestHandler oldHandler = conOne.registerIQRequestHandler(rosterPushHandler);
        rosterPushHandler.setDelegate(oldHandler); // Allows Smack internal classes (like Roster) to keep on processing roster changes.

        try
        {
            // Execute System Under test: apply a roster change.
            final ResultSyncPoint<RosterPacket, Exception> rosterUpdatePushReceived = new ResultSyncPoint<>();
            rosterPushHandler.registerSyncPointFor(rosterUpdatePushReceived, changeTarget);

            conOne.sendIqRequestAndWaitForResponse(change);

            final String rosterVerAfterModification = rosterUpdatePushReceived.waitForResult(timeout).getVersion();

            // Verify result.
            assertNotEquals(rosterVerWithoutModification, rosterVerAfterModification, "Expected that the roster 'ver' value that is pushed to '" + conOne.getUser() + "' after its roster was changed (" + descriptionOfChange + ") is different from the value that was pushed prior the change, but the same roster 'ver' value was received!");
        }
        finally
        {
            // Clean up test fixture.
            if (oldHandler != null) {
                conOne.registerIQRequestHandler(oldHandler);
            } else {
                conOne.unregisterIQRequestHandler(rosterPushHandler);
            }

            final Roster roster = Roster.getInstanceFor(conOne);
            final RosterEntry startingPointEntry = roster.getEntry(startingPointTarget);
            if (startingPointEntry != null) {
                roster.removeEntry(startingPointEntry);
            }
            if (!startingPointTarget.equals(changeTarget)) {
                final RosterEntry changeEntry = roster.getEntry(changeTarget);
                if (changeEntry != null) {
                    roster.removeEntry(changeEntry);
                }
            }
        }
    }
}
